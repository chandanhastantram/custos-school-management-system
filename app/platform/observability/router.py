"""
CUSTOS Platform Observability API

Admin-only endpoints for platform observability.

NO UI - JSON summaries only.

Access: Platform admins only
"""

import logging
from typing import Optional
from uuid import UUID

from fastapi import APIRouter, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.database import get_db
from app.platform.admin.dependencies import CurrentPlatformAdmin
from app.platform.observability.metrics import get_metrics_collector
from app.platform.observability.snapshots import get_snapshot_service
from app.platform.observability.collectors import (
    get_observability_collector,
    get_alert_checker,
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/observability", tags=["Platform Observability"])


# ============================================
# Platform-Wide Endpoints
# ============================================

@router.get("/platform/summary")
async def get_platform_summary(
    admin: CurrentPlatformAdmin,
):
    """
    Get platform-wide health summary.
    
    Returns:
    - Overall platform status
    - Tenant health breakdown
    - Feature availability
    - Key metrics
    """
    snapshots = get_snapshot_service()
    return snapshots.get_platform_snapshot()


@router.get("/platform/metrics")
async def get_platform_metrics(
    admin: CurrentPlatformAdmin,
):
    """
    Get platform-wide aggregated metrics.
    
    Returns:
    - Total request count
    - Total error count
    - AI token usage
    - Cache hit ratio
    - Active tenant count
    """
    metrics = get_metrics_collector()
    return metrics.get_platform_metrics()


@router.get("/platform/features")
async def get_feature_health(
    admin: CurrentPlatformAdmin,
):
    """
    Get health status of all features.
    
    Shows which features are:
    - Available (circuit closed)
    - Degraded (circuit half-open)
    - Unavailable (circuit open)
    """
    snapshots = get_snapshot_service()
    return snapshots.get_feature_health_summary()


@router.get("/platform/alerts")
async def get_recent_alerts(
    admin: CurrentPlatformAdmin,
    limit: int = Query(default=50, le=100),
    severity: Optional[str] = Query(default=None),
):
    """
    Get recent alerts generated by threshold breaches.
    
    Optional filter by severity: info, warning, critical
    """
    alerts = get_alert_checker()
    
    if severity:
        return {"alerts": alerts.get_alerts_by_severity(severity)}
    
    return {"alerts": alerts.get_recent_alerts(limit)}


@router.post("/platform/collect")
async def trigger_collection(
    admin: CurrentPlatformAdmin,
):
    """
    Manually trigger a metric collection cycle.
    
    Checks all tenants and generates alerts if thresholds exceeded.
    """
    collector = get_observability_collector()
    result = await collector.collect_and_check()
    return result


# ============================================
# Tenant-Level Endpoints
# ============================================

@router.get("/tenants")
async def list_tenant_metrics(
    admin: CurrentPlatformAdmin,
    limit: int = Query(default=50, le=100),
    sort_by: str = Query(default="requests", regex="^(requests|errors|ai_tokens)$"),
):
    """
    List all tenants with their current metrics.
    
    Sort by: requests, errors, or ai_tokens
    """
    metrics = get_metrics_collector()
    
    if sort_by == "requests":
        return {"tenants": metrics.get_top_tenants_by_requests(limit)}
    elif sort_by == "errors":
        return {"tenants": metrics.get_top_tenants_by_errors(limit)}
    elif sort_by == "ai_tokens":
        return {"tenants": metrics.get_top_tenants_by_ai_usage(limit)}
    
    return {"tenants": metrics.get_all_tenant_metrics()[:limit]}


@router.get("/tenants/degraded")
async def get_degraded_tenants(
    admin: CurrentPlatformAdmin,
    error_rate_threshold: float = Query(default=0.05, ge=0, le=1),
):
    """
    Get tenants currently experiencing degradation.
    
    Filters by error rate above threshold (default 5%).
    """
    snapshots = get_snapshot_service()
    return {"degraded_tenants": snapshots.get_degraded_tenants()}


@router.get("/tenants/top-errors")
async def get_top_error_tenants(
    admin: CurrentPlatformAdmin,
    limit: int = Query(default=10, le=50),
):
    """
    Get tenants with highest error counts.
    
    Useful for identifying problematic tenants.
    """
    metrics = get_metrics_collector()
    return {"tenants": metrics.get_top_tenants_by_errors(limit)}


@router.get("/tenants/top-ai-usage")
async def get_top_ai_usage_tenants(
    admin: CurrentPlatformAdmin,
    limit: int = Query(default=10, le=50),
):
    """
    Get tenants with highest AI token usage.
    
    Useful for capacity planning and usage tracking.
    """
    metrics = get_metrics_collector()
    return {"tenants": metrics.get_top_tenants_by_ai_usage(limit)}


@router.get("/tenants/{tenant_id}")
async def get_tenant_metrics(
    tenant_id: UUID,
    admin: CurrentPlatformAdmin,
):
    """
    Get detailed metrics for a specific tenant.
    """
    metrics = get_metrics_collector()
    return metrics.get_tenant_metrics(tenant_id)


@router.get("/tenants/{tenant_id}/health")
async def get_tenant_health(
    tenant_id: UUID,
    admin: CurrentPlatformAdmin,
):
    """
    Get full health snapshot for a specific tenant.
    
    Includes:
    - Overall health status
    - Feature availability
    - Metrics summary
    - Capacity warnings
    """
    snapshots = get_snapshot_service()
    snapshot = snapshots.get_tenant_snapshot(tenant_id)
    return snapshot.to_dict()


# ============================================
# Capacity Planning Endpoints
# ============================================

@router.get("/capacity/summary")
async def get_capacity_summary(
    admin: CurrentPlatformAdmin,
):
    """
    Get capacity planning summary.
    
    Shows:
    - Current load
    - Growth indicators
    - Approaching limits
    """
    metrics = get_metrics_collector()
    platform = metrics.get_platform_metrics()
    
    return {
        "current_load": {
            "active_tenants": platform.get("active_tenants", 0),
            "total_requests": platform.get("platform", {}).get("counters", {}).get("requests", 0),
            "total_ai_tokens": platform.get("platform", {}).get("counters", {}).get("ai_tokens", 0),
        },
        "capacity_indicators": {
            # These would be calculated from actual limits
            "tenant_capacity_used_pct": min(
                platform.get("active_tenants", 0) / 1000 * 100, 100  # Assuming 1000 tenant limit
            ),
            "can_onboard_more": platform.get("active_tenants", 0) < 900,
        },
    }


@router.get("/capacity/tenants-at-risk")
async def get_tenants_at_risk(
    admin: CurrentPlatformAdmin,
):
    """
    Get tenants approaching their limits.
    
    Identifies tenants that may need attention:
    - High AI usage
    - High error rates
    - Slow response times
    """
    metrics = get_metrics_collector()
    all_metrics = metrics.get_all_tenant_metrics()
    
    at_risk = []
    
    for tm in all_metrics:
        tenant_id = tm.get("tenant_id")
        counters = tm.get("counters", {})
        rates = tm.get("rates", {})
        response_times = tm.get("response_times", {})
        
        risks = []
        
        # High AI usage
        if counters.get("ai_tokens", 0) > 80000:
            risks.append("high_ai_usage")
        
        # High error rate
        if rates.get("error_rate", 0) > 0.05:
            risks.append("high_error_rate")
        
        # Slow responses
        if response_times.get("p95_ms", 0) > 1000:
            risks.append("slow_responses")
        
        if risks:
            at_risk.append({
                "tenant_id": tenant_id,
                "risks": risks,
                "metrics": tm,
            })
    
    return {"tenants_at_risk": at_risk}
