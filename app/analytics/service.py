"""
CUSTOS Analytics Service

Deterministic analytics engine with strict visibility rules.

CORE PRINCIPLES:
1. NO student-to-student comparison
2. Activity Score visible to students, Actual Score hidden
3. Immutable snapshots, regenerated by admin/cron only
4. No AI - pure aggregation
"""

from datetime import datetime, date, timezone, timedelta
from decimal import Decimal
from typing import Optional, List, Tuple, Dict
from uuid import UUID

from sqlalchemy import select, func, and_, or_
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.exceptions import ResourceNotFoundError, ValidationError
from app.analytics.models import (
    StudentAnalyticsSnapshot,
    TeacherAnalyticsSnapshot,
    ClassAnalyticsSnapshot,
    AnalyticsPeriod,
)


class AnalyticsService:
    """
    Service for deterministic analytics operations.
    
    This service DOES NOT:
    - Rank students
    - Create leaderboards
    - Compare students to each other
    - Use AI predictions
    """
    
    # Weights for activity score calculation
    DAILY_LOOP_WEIGHT = 0.30
    WEEKLY_TEST_WEIGHT = 0.25
    LESSON_EVAL_WEIGHT = 0.25
    ATTENDANCE_WEIGHT = 0.20
    
    # Weights for actual performance score
    DAILY_MASTERY_WEIGHT = 0.35
    WEEKLY_MASTERY_WEIGHT = 0.40
    LESSON_MASTERY_WEIGHT = 0.25
    
    # Weights for teacher engagement score
    SYLLABUS_COVERAGE_WEIGHT = 0.30
    SCHEDULE_ADHERENCE_WEIGHT = 0.30
    STUDENT_PARTICIPATION_WEIGHT = 0.40
    
    def __init__(self, session: AsyncSession, tenant_id: UUID):
        self.session = session
        self.tenant_id = tenant_id
    
    # ============================================
    # Student Snapshot Generation
    # ============================================
    
    async def generate_student_snapshot(
        self,
        student_id: UUID,
        class_id: UUID,
        period_start: date,
        period_end: date,
        period_type: AnalyticsPeriod = AnalyticsPeriod.WEEKLY,
        subject_id: Optional[UUID] = None,
        generated_by: Optional[UUID] = None,
    ) -> StudentAnalyticsSnapshot:
        """
        Generate analytics snapshot for a student.
        
        This aggregates data from:
        - Daily loops
        - Weekly tests
        - Lesson evaluations
        - Attendance records
        """
        # Fetch raw data (would query actual tables in production)
        daily_data = await self._get_daily_loop_data(
            student_id, period_start, period_end, subject_id
        )
        weekly_data = await self._get_weekly_test_data(
            student_id, period_start, period_end, subject_id
        )
        lesson_data = await self._get_lesson_eval_data(
            student_id, period_start, period_end, subject_id
        )
        attendance_data = await self._get_attendance_data(
            student_id, period_start, period_end
        )
        
        # Calculate activity score (participation only)
        activity_score = self._calculate_activity_score(
            daily_data["participation_pct"],
            weekly_data["participation_pct"],
            lesson_data["participation_pct"],
            attendance_data["attendance_pct"],
        )
        
        # Calculate actual performance score (mastery)
        actual_score = self._calculate_actual_score(
            daily_data["mastery_pct"],
            weekly_data["mastery_pct"],
            lesson_data["mastery_pct"],
        )
        
        # Get concepts analysis
        weak_concepts, strong_concepts = await self._analyze_concepts(
            student_id, period_start, period_end, subject_id
        )
        
        # Create snapshot
        snapshot = StudentAnalyticsSnapshot(
            tenant_id=self.tenant_id,
            student_id=student_id,
            class_id=class_id,
            subject_id=subject_id,
            period_type=period_type,
            period_start=period_start,
            period_end=period_end,
            
            # Activity Score (student-visible)
            activity_score=Decimal(str(activity_score)),
            daily_loop_participation_pct=Decimal(str(daily_data["participation_pct"])),
            weekly_test_participation_pct=Decimal(str(weekly_data["participation_pct"])),
            lesson_eval_participation_pct=Decimal(str(lesson_data["participation_pct"])),
            attendance_pct=Decimal(str(attendance_data["attendance_pct"])),
            
            # Actual Performance Score (hidden from students)
            actual_score=Decimal(str(actual_score)),
            daily_mastery_pct=Decimal(str(daily_data["mastery_pct"])),
            weekly_test_mastery_pct=Decimal(str(weekly_data["mastery_pct"])),
            lesson_eval_mastery_pct=Decimal(str(lesson_data["mastery_pct"])),
            overall_mastery_pct=Decimal(str(actual_score)),
            
            # Raw counts
            daily_loops_total=daily_data["total"],
            daily_loops_completed=daily_data["completed"],
            weekly_tests_total=weekly_data["total"],
            weekly_tests_completed=weekly_data["completed"],
            lesson_evals_total=lesson_data["total"],
            lesson_evals_completed=lesson_data["completed"],
            school_days_total=attendance_data["total_days"],
            school_days_present=attendance_data["present_days"],
            
            # Concepts
            weak_concepts_json=weak_concepts,
            strong_concepts_json=strong_concepts,
            
            # Metadata
            generated_at=datetime.now(timezone.utc),
            generated_by=generated_by,
        )
        
        self.session.add(snapshot)
        await self.session.commit()
        await self.session.refresh(snapshot)
        return snapshot
    
    def _calculate_activity_score(
        self,
        daily_participation: float,
        weekly_participation: float,
        lesson_participation: float,
        attendance: float,
    ) -> float:
        """
        Calculate activity score from participation metrics.
        
        This score is VISIBLE to students.
        It measures PARTICIPATION, not correctness.
        """
        score = (
            daily_participation * self.DAILY_LOOP_WEIGHT +
            weekly_participation * self.WEEKLY_TEST_WEIGHT +
            lesson_participation * self.LESSON_EVAL_WEIGHT +
            attendance * self.ATTENDANCE_WEIGHT
        )
        return min(100.0, max(0.0, score))
    
    def _calculate_actual_score(
        self,
        daily_mastery: float,
        weekly_mastery: float,
        lesson_mastery: float,
    ) -> float:
        """
        Calculate actual performance score from mastery metrics.
        
        This score is HIDDEN from students.
        It measures actual learning outcomes.
        """
        score = (
            daily_mastery * self.DAILY_MASTERY_WEIGHT +
            weekly_mastery * self.WEEKLY_MASTERY_WEIGHT +
            lesson_mastery * self.LESSON_MASTERY_WEIGHT
        )
        return min(100.0, max(0.0, score))
    
    async def _get_daily_loop_data(
        self,
        student_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
    ) -> Dict:
        """Fetch daily loop participation and mastery data."""
        # In production, this would query the daily_loop_sessions table
        # For now, return placeholder structure
        # TODO: Integrate with actual DailyLoopSession model
        
        return {
            "total": 0,
            "completed": 0,
            "participation_pct": 0.0,
            "mastery_pct": 0.0,
        }
    
    async def _get_weekly_test_data(
        self,
        student_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
    ) -> Dict:
        """Fetch weekly test participation and mastery data."""
        # In production, this would query the weekly_test_sessions table
        # TODO: Integrate with actual WeeklyTestSession model
        
        return {
            "total": 0,
            "completed": 0,
            "participation_pct": 0.0,
            "mastery_pct": 0.0,
        }
    
    async def _get_lesson_eval_data(
        self,
        student_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
    ) -> Dict:
        """Fetch lesson evaluation participation and mastery data."""
        # In production, this would query the lesson_test_sessions table
        # TODO: Integrate with actual LessonTestSession model
        
        return {
            "total": 0,
            "completed": 0,
            "participation_pct": 0.0,
            "mastery_pct": 0.0,
        }
    
    async def _get_attendance_data(
        self,
        student_id: UUID,
        period_start: date,
        period_end: date,
    ) -> Dict:
        """Fetch attendance data."""
        # In production, this would query the attendance_records table
        # TODO: Integrate with actual AttendanceRecord model
        
        return {
            "total_days": 0,
            "present_days": 0,
            "attendance_pct": 0.0,
        }
    
    async def _analyze_concepts(
        self,
        student_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
    ) -> Tuple[List, List]:
        """
        Analyze concept mastery for a student.
        
        Returns (weak_concepts, strong_concepts) lists.
        This is for personal improvement, NOT for comparison.
        """
        # In production, this would analyze question-level data
        # TODO: Integrate with actual mastery tracking
        
        return [], []
    
    # ============================================
    # Teacher Snapshot Generation
    # ============================================
    
    async def generate_teacher_snapshot(
        self,
        teacher_id: UUID,
        period_start: date,
        period_end: date,
        period_type: AnalyticsPeriod = AnalyticsPeriod.WEEKLY,
        subject_id: Optional[UUID] = None,
        class_id: Optional[UUID] = None,
        generated_by: Optional[UUID] = None,
    ) -> TeacherAnalyticsSnapshot:
        """
        Generate analytics snapshot for a teacher.
        
        This aggregates data from:
        - Lesson plans
        - Schedule records
        - Student participation rates
        - Assessment creation activity
        """
        # Fetch raw data
        lesson_data = await self._get_teacher_lesson_data(
            teacher_id, period_start, period_end, subject_id, class_id
        )
        schedule_data = await self._get_teacher_schedule_data(
            teacher_id, period_start, period_end, subject_id, class_id
        )
        participation_data = await self._get_class_participation_data(
            teacher_id, period_start, period_end, subject_id, class_id
        )
        assessment_data = await self._get_teacher_assessment_data(
            teacher_id, period_start, period_end, subject_id
        )
        
        # Calculate engagement score
        engagement_score = self._calculate_teacher_engagement_score(
            lesson_data["coverage_pct"],
            schedule_data["adherence_pct"],
            participation_data["participation_pct"],
        )
        
        # Create snapshot
        snapshot = TeacherAnalyticsSnapshot(
            tenant_id=self.tenant_id,
            teacher_id=teacher_id,
            subject_id=subject_id,
            class_id=class_id,
            period_type=period_type,
            period_start=period_start,
            period_end=period_end,
            
            # Teaching metrics
            syllabus_coverage_pct=Decimal(str(lesson_data["coverage_pct"])),
            lessons_planned=lesson_data["planned"],
            lessons_completed=lesson_data["completed"],
            schedule_adherence_pct=Decimal(str(schedule_data["adherence_pct"])),
            periods_scheduled=schedule_data["scheduled"],
            periods_conducted=schedule_data["conducted"],
            
            # Student engagement
            student_participation_pct=Decimal(str(participation_data["participation_pct"])),
            class_mastery_avg=Decimal(str(participation_data["mastery_avg"])),
            
            # Assessment activity
            daily_loops_created=assessment_data["daily_loops"],
            weekly_tests_created=assessment_data["weekly_tests"],
            lesson_evals_created=assessment_data["lesson_evals"],
            
            # Overall score
            engagement_score=Decimal(str(engagement_score)),
            
            # Metadata
            generated_at=datetime.now(timezone.utc),
            generated_by=generated_by,
        )
        
        self.session.add(snapshot)
        await self.session.commit()
        await self.session.refresh(snapshot)
        return snapshot
    
    def _calculate_teacher_engagement_score(
        self,
        syllabus_coverage: float,
        schedule_adherence: float,
        student_participation: float,
    ) -> float:
        """Calculate teacher engagement score."""
        score = (
            syllabus_coverage * self.SYLLABUS_COVERAGE_WEIGHT +
            schedule_adherence * self.SCHEDULE_ADHERENCE_WEIGHT +
            student_participation * self.STUDENT_PARTICIPATION_WEIGHT
        )
        return min(100.0, max(0.0, score))
    
    async def _get_teacher_lesson_data(
        self,
        teacher_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
        class_id: Optional[UUID] = None,
    ) -> Dict:
        """Fetch teacher's lesson plan data."""
        # TODO: Integrate with LessonPlan model
        return {
            "planned": 0,
            "completed": 0,
            "coverage_pct": 0.0,
        }
    
    async def _get_teacher_schedule_data(
        self,
        teacher_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
        class_id: Optional[UUID] = None,
    ) -> Dict:
        """Fetch teacher's schedule adherence data."""
        # TODO: Integrate with Schedule model
        return {
            "scheduled": 0,
            "conducted": 0,
            "adherence_pct": 0.0,
        }
    
    async def _get_class_participation_data(
        self,
        teacher_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
        class_id: Optional[UUID] = None,
    ) -> Dict:
        """Fetch class participation data for a teacher."""
        # TODO: Integrate with session models
        return {
            "participation_pct": 0.0,
            "mastery_avg": 0.0,
        }
    
    async def _get_teacher_assessment_data(
        self,
        teacher_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
    ) -> Dict:
        """Fetch teacher's assessment creation data."""
        # TODO: Integrate with assessment models
        return {
            "daily_loops": 0,
            "weekly_tests": 0,
            "lesson_evals": 0,
        }
    
    # ============================================
    # Class Snapshot Generation
    # ============================================
    
    async def generate_class_snapshot(
        self,
        class_id: UUID,
        period_start: date,
        period_end: date,
        period_type: AnalyticsPeriod = AnalyticsPeriod.WEEKLY,
        subject_id: Optional[UUID] = None,
        generated_by: Optional[UUID] = None,
    ) -> ClassAnalyticsSnapshot:
        """
        Generate analytics snapshot for a class.
        
        This creates AGGREGATE data only.
        NO individual student data is exposed.
        """
        # Get student snapshots for this class and period
        student_snapshots = await self._get_class_student_snapshots(
            class_id, period_start, period_end, subject_id
        )
        
        total_students = len(student_snapshots)
        
        if total_students == 0:
            # No data, return empty snapshot
            snapshot = ClassAnalyticsSnapshot(
                tenant_id=self.tenant_id,
                class_id=class_id,
                subject_id=subject_id,
                period_type=period_type,
                period_start=period_start,
                period_end=period_end,
                total_students=0,
                avg_mastery_pct=Decimal("0"),
                avg_activity_score=Decimal("0"),
                avg_attendance_pct=Decimal("0"),
                daily_loop_participation_avg=Decimal("0"),
                weekly_test_participation_avg=Decimal("0"),
                lesson_eval_participation_avg=Decimal("0"),
                syllabus_coverage_pct=Decimal("0"),
                generated_at=datetime.now(timezone.utc),
                generated_by=generated_by,
            )
        else:
            # Calculate aggregates (averages only, no ranking)
            avg_mastery = sum(s.overall_mastery_pct for s in student_snapshots) / total_students
            avg_activity = sum(s.activity_score for s in student_snapshots) / total_students
            avg_attendance = sum(s.attendance_pct for s in student_snapshots) / total_students
            avg_daily_participation = sum(s.daily_loop_participation_pct for s in student_snapshots) / total_students
            avg_weekly_participation = sum(s.weekly_test_participation_pct for s in student_snapshots) / total_students
            avg_lesson_participation = sum(s.lesson_eval_participation_pct for s in student_snapshots) / total_students
            
            # Analyze common topics (patterns, not rankings)
            common_weak, common_strong, weak_count, strong_count = await self._analyze_class_topics(
                student_snapshots
            )
            
            # Get syllabus coverage from teacher data
            syllabus_coverage = await self._get_class_syllabus_coverage(
                class_id, subject_id, period_start, period_end
            )
            
            snapshot = ClassAnalyticsSnapshot(
                tenant_id=self.tenant_id,
                class_id=class_id,
                subject_id=subject_id,
                period_type=period_type,
                period_start=period_start,
                period_end=period_end,
                total_students=total_students,
                avg_mastery_pct=avg_mastery,
                avg_activity_score=avg_activity,
                avg_attendance_pct=avg_attendance,
                daily_loop_participation_avg=avg_daily_participation,
                weekly_test_participation_avg=avg_weekly_participation,
                lesson_eval_participation_avg=avg_lesson_participation,
                common_weak_topics_json=common_weak,
                common_strong_topics_json=common_strong,
                weak_topic_count=weak_count,
                strong_topic_count=strong_count,
                syllabus_coverage_pct=Decimal(str(syllabus_coverage)),
                generated_at=datetime.now(timezone.utc),
                generated_by=generated_by,
            )
        
        self.session.add(snapshot)
        await self.session.commit()
        await self.session.refresh(snapshot)
        return snapshot
    
    async def _get_class_student_snapshots(
        self,
        class_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
    ) -> List[StudentAnalyticsSnapshot]:
        """Get existing student snapshots for a class."""
        query = select(StudentAnalyticsSnapshot).where(
            StudentAnalyticsSnapshot.tenant_id == self.tenant_id,
            StudentAnalyticsSnapshot.class_id == class_id,
            StudentAnalyticsSnapshot.period_start == period_start,
            StudentAnalyticsSnapshot.period_end == period_end,
        )
        if subject_id:
            query = query.where(StudentAnalyticsSnapshot.subject_id == subject_id)
        
        result = await self.session.execute(query)
        return list(result.scalars().all())
    
    async def _analyze_class_topics(
        self,
        snapshots: List[StudentAnalyticsSnapshot],
    ) -> Tuple[List, List, int, int]:
        """
        Analyze common topic patterns in a class.
        
        This identifies areas needing attention, NOT rankings.
        """
        # Aggregate topic data from snapshots
        weak_topics = {}
        strong_topics = {}
        
        for snapshot in snapshots:
            if snapshot.weak_concepts_json:
                for concept in snapshot.weak_concepts_json:
                    name = concept.get("name", "")
                    if name:
                        weak_topics[name] = weak_topics.get(name, 0) + 1
            
            if snapshot.strong_concepts_json:
                for concept in snapshot.strong_concepts_json:
                    name = concept.get("name", "")
                    if name:
                        strong_topics[name] = strong_topics.get(name, 0) + 1
        
        # Sort by frequency (most common across students)
        common_weak = [
            {"name": k, "student_count": v}
            for k, v in sorted(weak_topics.items(), key=lambda x: -x[1])[:10]
        ]
        common_strong = [
            {"name": k, "student_count": v}
            for k, v in sorted(strong_topics.items(), key=lambda x: -x[1])[:10]
        ]
        
        return common_weak, common_strong, len(weak_topics), len(strong_topics)
    
    async def _get_class_syllabus_coverage(
        self,
        class_id: UUID,
        subject_id: Optional[UUID],
        period_start: date,
        period_end: date,
    ) -> float:
        """Get syllabus coverage for a class."""
        # TODO: Integrate with lesson plan completion
        return 0.0
    
    # ============================================
    # Bulk Generation
    # ============================================
    
    async def generate_all_snapshots(
        self,
        period_start: date,
        period_end: date,
        period_type: AnalyticsPeriod = AnalyticsPeriod.WEEKLY,
        class_id: Optional[UUID] = None,
        subject_id: Optional[UUID] = None,
        generated_by: Optional[UUID] = None,
    ) -> Tuple[int, int, int]:
        """
        Generate all analytics snapshots for a period.
        
        Returns (students_count, teachers_count, classes_count).
        """
        students_count = 0
        teachers_count = 0
        classes_count = 0
        
        # TODO: Implement bulk generation
        # 1. Get all active students (optionally filter by class)
        # 2. Generate student snapshots
        # 3. Get all active teachers
        # 4. Generate teacher snapshots
        # 5. Get all classes
        # 6. Generate class snapshots
        
        return students_count, teachers_count, classes_count
    
    # ============================================
    # Query Methods
    # ============================================
    
    async def get_student_snapshot(
        self,
        student_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
    ) -> Optional[StudentAnalyticsSnapshot]:
        """Get a student's snapshot for a period."""
        query = select(StudentAnalyticsSnapshot).where(
            StudentAnalyticsSnapshot.tenant_id == self.tenant_id,
            StudentAnalyticsSnapshot.student_id == student_id,
            StudentAnalyticsSnapshot.period_start == period_start,
            StudentAnalyticsSnapshot.period_end == period_end,
        )
        if subject_id:
            query = query.where(StudentAnalyticsSnapshot.subject_id == subject_id)
        
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_student_history(
        self,
        student_id: UUID,
        weeks: int = 4,
        subject_id: Optional[UUID] = None,
    ) -> List[StudentAnalyticsSnapshot]:
        """Get student's historical snapshots for trend analysis."""
        today = date.today()
        start_date = today - timedelta(weeks=weeks)
        
        query = select(StudentAnalyticsSnapshot).where(
            StudentAnalyticsSnapshot.tenant_id == self.tenant_id,
            StudentAnalyticsSnapshot.student_id == student_id,
            StudentAnalyticsSnapshot.period_start >= start_date,
        )
        if subject_id:
            query = query.where(StudentAnalyticsSnapshot.subject_id == subject_id)
        
        query = query.order_by(StudentAnalyticsSnapshot.period_start.desc())
        
        result = await self.session.execute(query)
        return list(result.scalars().all())
    
    async def get_class_students_analytics(
        self,
        class_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
    ) -> List[StudentAnalyticsSnapshot]:
        """
        Get analytics for all students in a class.
        
        For TEACHERS only. No ranking or comparison.
        """
        query = select(StudentAnalyticsSnapshot).where(
            StudentAnalyticsSnapshot.tenant_id == self.tenant_id,
            StudentAnalyticsSnapshot.class_id == class_id,
            StudentAnalyticsSnapshot.period_start == period_start,
            StudentAnalyticsSnapshot.period_end == period_end,
        )
        if subject_id:
            query = query.where(StudentAnalyticsSnapshot.subject_id == subject_id)
        
        # Order by student name, NOT by score
        query = query.order_by(StudentAnalyticsSnapshot.student_id)
        
        result = await self.session.execute(query)
        return list(result.scalars().all())
    
    async def get_teacher_snapshot(
        self,
        teacher_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
        class_id: Optional[UUID] = None,
    ) -> Optional[TeacherAnalyticsSnapshot]:
        """Get a teacher's snapshot for a period."""
        query = select(TeacherAnalyticsSnapshot).where(
            TeacherAnalyticsSnapshot.tenant_id == self.tenant_id,
            TeacherAnalyticsSnapshot.teacher_id == teacher_id,
            TeacherAnalyticsSnapshot.period_start == period_start,
            TeacherAnalyticsSnapshot.period_end == period_end,
        )
        if subject_id:
            query = query.where(TeacherAnalyticsSnapshot.subject_id == subject_id)
        if class_id:
            query = query.where(TeacherAnalyticsSnapshot.class_id == class_id)
        
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_all_teachers_analytics(
        self,
        period_start: date,
        period_end: date,
    ) -> List[TeacherAnalyticsSnapshot]:
        """
        Get analytics for all teachers.
        
        For ADMIN/PRINCIPAL only.
        """
        query = select(TeacherAnalyticsSnapshot).where(
            TeacherAnalyticsSnapshot.tenant_id == self.tenant_id,
            TeacherAnalyticsSnapshot.period_start == period_start,
            TeacherAnalyticsSnapshot.period_end == period_end,
        ).order_by(TeacherAnalyticsSnapshot.teacher_id)
        
        result = await self.session.execute(query)
        return list(result.scalars().all())
    
    async def get_class_snapshot(
        self,
        class_id: UUID,
        period_start: date,
        period_end: date,
        subject_id: Optional[UUID] = None,
    ) -> Optional[ClassAnalyticsSnapshot]:
        """Get a class snapshot for a period."""
        query = select(ClassAnalyticsSnapshot).where(
            ClassAnalyticsSnapshot.tenant_id == self.tenant_id,
            ClassAnalyticsSnapshot.class_id == class_id,
            ClassAnalyticsSnapshot.period_start == period_start,
            ClassAnalyticsSnapshot.period_end == period_end,
        )
        if subject_id:
            query = query.where(ClassAnalyticsSnapshot.subject_id == subject_id)
        
        result = await self.session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_all_classes_analytics(
        self,
        period_start: date,
        period_end: date,
    ) -> List[ClassAnalyticsSnapshot]:
        """
        Get analytics for all classes.
        
        For ADMIN/PRINCIPAL only.
        """
        query = select(ClassAnalyticsSnapshot).where(
            ClassAnalyticsSnapshot.tenant_id == self.tenant_id,
            ClassAnalyticsSnapshot.period_start == period_start,
            ClassAnalyticsSnapshot.period_end == period_end,
        ).order_by(ClassAnalyticsSnapshot.class_id)
        
        result = await self.session.execute(query)
        return list(result.scalars().all())
    
    # ============================================
    # Dashboard Summaries
    # ============================================
    
    async def get_principal_dashboard(
        self,
        period_start: date,
        period_end: date,
    ) -> Dict:
        """
        Get principal dashboard summary.
        
        Aggregate insights only, NO individual student data.
        """
        # Get all class snapshots
        class_snapshots = await self.get_all_classes_analytics(period_start, period_end)
        
        # Get all teacher snapshots
        teacher_snapshots = await self.get_all_teachers_analytics(period_start, period_end)
        
        total_students = sum(s.total_students for s in class_snapshots)
        total_teachers = len(teacher_snapshots)
        total_classes = len(class_snapshots)
        
        if total_classes > 0:
            school_avg_mastery = sum(float(s.avg_mastery_pct) for s in class_snapshots) / total_classes
            school_avg_attendance = sum(float(s.avg_attendance_pct) for s in class_snapshots) / total_classes
            school_avg_activity = sum(float(s.avg_activity_score) for s in class_snapshots) / total_classes
            avg_syllabus_coverage = sum(float(s.syllabus_coverage_pct) for s in class_snapshots) / total_classes
        else:
            school_avg_mastery = 0.0
            school_avg_attendance = 0.0
            school_avg_activity = 0.0
            avg_syllabus_coverage = 0.0
        
        if total_teachers > 0:
            avg_teacher_engagement = sum(float(s.engagement_score) for s in teacher_snapshots) / total_teachers
        else:
            avg_teacher_engagement = 0.0
        
        # Attention areas (below 60% threshold)
        classes_needing_attention = sum(1 for s in class_snapshots if float(s.avg_mastery_pct) < 60)
        subjects_with_low_mastery = 0  # TODO: Calculate per subject
        
        return {
            "period_start": period_start,
            "period_end": period_end,
            "total_students": total_students,
            "total_teachers": total_teachers,
            "total_classes": total_classes,
            "school_avg_mastery": school_avg_mastery,
            "school_avg_attendance": school_avg_attendance,
            "school_avg_activity": school_avg_activity,
            "avg_syllabus_coverage": avg_syllabus_coverage,
            "avg_teacher_engagement": avg_teacher_engagement,
            "classes_needing_attention": classes_needing_attention,
            "subjects_with_low_mastery": subjects_with_low_mastery,
        }
    
    async def get_teacher_dashboard(
        self,
        teacher_id: UUID,
        period_start: date,
        period_end: date,
    ) -> Dict:
        """
        Get teacher's dashboard summary.
        """
        # Get teacher's snapshots
        query = select(TeacherAnalyticsSnapshot).where(
            TeacherAnalyticsSnapshot.tenant_id == self.tenant_id,
            TeacherAnalyticsSnapshot.teacher_id == teacher_id,
            TeacherAnalyticsSnapshot.period_start == period_start,
            TeacherAnalyticsSnapshot.period_end == period_end,
        )
        result = await self.session.execute(query)
        snapshots = list(result.scalars().all())
        
        total_classes = len(set(s.class_id for s in snapshots if s.class_id))
        
        if snapshots:
            avg_syllabus_coverage = sum(float(s.syllabus_coverage_pct) for s in snapshots) / len(snapshots)
            avg_student_participation = sum(float(s.student_participation_pct) for s in snapshots) / len(snapshots)
            avg_class_mastery = sum(float(s.class_mastery_avg) for s in snapshots) / len(snapshots)
            engagement_score = sum(float(s.engagement_score) for s in snapshots) / len(snapshots)
        else:
            avg_syllabus_coverage = 0.0
            avg_student_participation = 0.0
            avg_class_mastery = 0.0
            engagement_score = 0.0
        
        return {
            "teacher_id": teacher_id,
            "period_start": period_start,
            "period_end": period_end,
            "total_classes": total_classes,
            "total_students": 0,  # TODO: Calculate
            "avg_syllabus_coverage": avg_syllabus_coverage,
            "avg_student_participation": avg_student_participation,
            "avg_class_mastery": avg_class_mastery,
            "engagement_score": engagement_score,
        }
